stages:
  - test
  - build
  - setup
  - deploy-database
  - deploy-llm
  - setup-database
  - deploy-api
  - check

############################################
################# CONFIG ###################
############################################

before_script:
  - | # export env file and copy routing table to pyalbert config
    if [[ -z $CI_ENVIRONMENT_NAME ]]; then
      echo "info: CI_ENVIRONMENT_NAME is empty, skip the export"

    else
      if [[ $CI_COMMIT_BRANCH = "staging" ]]; then
        echo "info: export staging env file of $CI_ENVIRONMENT_NAME environment"
        export $(grep -v "^#" $STAGING__ENV_FILE | xargs)
        cp $STAGING__ENV_FILE ./.env
        echo "info: copy staging routing table to pyalbert config"
        cp $STAGING__LLM_ROUTING_TABLE ./llm_routing_table.json

      elif [[ $CI_COMMIT_BRANCH = "main" ]]; then
        echo "info: export production env file of $CI_ENVIRONMENT_NAME environment"
        export $(grep -v "^#" $PROD__ENV_FILE | xargs)
        cp $PROD__ENV_FILE ./.env
        echo "info: copy production routing table to pyalbert config"
        cp $PROD__LLM_ROUTING_TABLE ./llm_routing_table.json
      fi
      echo "POSTGRES_HOST=${CI_DEPLOY_HOST}" >> ./.env
      echo "QDRANT_HOST=${CI_DEPLOY_HOST}" >> ./.env
      echo "ELASTIC_HOST=${CI_DEPLOY_HOST}" >> ./.env
      echo "EMBEDDINGS_HOST=${CI_DEPLOY_HOST}" >> ./.env
    fi

cache:
  paths:
    - .cache/pip
    - venv/

############################################
################# TEST #####################
############################################

test:api:
  stage: test
  image: python:3.10-slim
  rules:
    - if: '$CI_COMMIT_BRANCH == "prod" || $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "dev"'
      changes:
        - "api/app/**/*.py"
      when: always
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "prod" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "staging" ||$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "dev"'
      changes:
        - "api/app/**/*.py"
      when: always
  before_script:
  - |
    python -m venv venv
    source venv/bin/activate
    pip install --cache-dir .cache/pip -r api/requirements.txt
    pip install --cache-dir .cache/pip -r pyalbert/requirements.txt
    pip install --cache-dir .cache/pip -r api/requirements_dev.txt
  script:
    - cp -r pyalbert api/ && cd api/ && pytest -W ignore app/tests/


############################################
################# DATABASE #################
############################################

################## DINUM ###################

deploy:database:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-database
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./databases/docker-compose.yml ./${CI_JOB_ID}/docker-compose.yml
      cp ./.env ./${CI_JOB_ID}/.env
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy database to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      export COMPOSE_FILE=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/docker-compose.yml
      export COMPOSE_PROJECT_NAME=database
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env down
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env up --detach
      "

setup:database:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup-database
  image: alpine:latest
  timeout: 3 hours
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      mkdir -p ./${CI_JOB_ID}/venv
      cp -r ./pyalbert ./${CI_JOB_ID}
      cp ./.env ./${CI_JOB_ID}/.env
      sed -i~ "s/QDRANT_HOST=${CI_DEPLOY_HOST}/QDRANT_HOST=localhost/g" ./${CI_JOB_ID}/.env
      sed -i~ "s/ELASTIC_HOST=${CI_DEPLOY_HOST}/ELASTIC_HOST=localhost/g" ./${CI_JOB_ID}/.env
      sed -i~ "s/EMBEDDINGS_HOST=${CI_DEPLOY_HOST}/EMBEDDINGS_HOST=localhost/g" ./${CI_JOB_ID}/.env
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # setup database on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      export $(grep -v "^#" ~/${CI_JOB_ID}/.env | xargs)
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/pyalbert
      python ./albert.py download_rag_sources
      python ./albert.py make_chunks --structured
      python ./albert.py index experiences --index-type bm25
      python ./albert.py index sheets --index-type bm25
      python ./albert.py index chunks --index-type bm25
      python ./albert.py index experiences --index-type e5
      python ./albert.py index chunks --index-type e5
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

############# FRANCE SERVICES ##############

deploy:database:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-database
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./databases/docker-compose.yml ./${CI_JOB_ID}/docker-compose.yml
      cp ./.env ./${CI_JOB_ID}/.env
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy database to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      export COMPOSE_FILE=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/docker-compose.yml
      export COMPOSE_PROJECT_NAME=database
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env down
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env up --detach
      "

setup:database:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup-database
  image: alpine:latest
  timeout: 3 hours
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      mkdir -p ./${CI_JOB_ID}/venv
      cp -r ./pyalbert ./${CI_JOB_ID}
      cp ./.env ./${CI_JOB_ID}/.env
      sed -i~ "s/QDRANT_HOST=${CI_DEPLOY_HOST}/QDRANT_HOST=localhost/g" ./${CI_JOB_ID}/.env
      sed -i~ "s/ELASTIC_HOST=${CI_DEPLOY_HOST}/ELASTIC_HOST=localhost/g" ./${CI_JOB_ID}/.env
      sed -i~ "s/EMBEDDINGS_HOST=${CI_DEPLOY_HOST}/EMBEDDINGS_HOST=localhost/g" ./${CI_JOB_ID}/.env
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # setup database on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      export $(grep -v "^#" ~/${CI_JOB_ID}/.env | xargs)
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/pyalbert
      python ./albert.py download_rag_sources
      python ./albert.py make_chunks --structured
      python ./albert.py index experiences --index-type bm25
      python ./albert.py index sheets --index-type bm25
      python ./albert.py index chunks --index-type bm25
      python ./albert.py index experiences --index-type e5
      python ./albert.py index chunks --index-type e5
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

############################################
################ EMBEDDINGS ################
############################################

build:embeddings:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      # changes:
      #   - embeddings/**/* # only build if embeddings folder is changed
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - | # build and push embeddings image to gitlab registry
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker build --tag ${CI_REGISTRY_IMAGE}/embeddings:${CI_EMBEDDINGS_IMAGE_TAG} --build-context pyalbert=./pyalbert --file ./embeddings/Dockerfile ./embeddings
      docker push ${CI_REGISTRY_IMAGE}/embeddings:${CI_EMBEDDINGS_IMAGE_TAG}

################## DINUM ###################

deploy:embeddings:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-llm
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./.env ./${CI_JOB_ID}/.env
      cp ./embeddings/docker-compose.yml ./${CI_JOB_ID}/docker-compose.yml
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy embeddings containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_EMBEDDINGS_IMAGE_TAG=${CI_EMBEDDINGS_IMAGE_TAG}
      export COMPOSE_FILE=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/docker-compose.yml
      export COMPOSE_PROJECT_NAME=embeddings
      export MODELS_DIR=/data/models
      export FORCE_DOWNLOAD=""
      export DEBUG=""
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env down
      docker image rm ${CI_REGISTRY_IMAGE}/embeddings:${CI_EMBEDDINGS_IMAGE_TAG} || true
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env up --detach
      rm -rf ~/${CI_JOB_ID}
      "

############# FRANCE SERVICES ##############

deploy:embeddings:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-llm
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./.env ./${CI_JOB_ID}/.env
      cp ./embeddings/docker-compose.yml ./${CI_JOB_ID}/docker-compose.yml
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy embeddings containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_EMBEDDINGS_IMAGE_TAG=${CI_EMBEDDINGS_IMAGE_TAG}
      export COMPOSE_FILE=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/docker-compose.yml
      export COMPOSE_PROJECT_NAME=embeddings
      export MODELS_DIR=/data/models
      export FORCE_DOWNLOAD=""
      export DEBUG=""
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env down
      docker image rm ${CI_REGISTRY_IMAGE}/embeddings:${CI_EMBEDDINGS_IMAGE_TAG} || true
      docker compose --env-file /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/.env up --detach
      rm -rf ~/${CI_JOB_ID}
      "


############################################
#################### LLM ###################
############################################

build:llm:gpt4all:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      # changes:
      #   - llm/gpt4all/**/* # only build if llm/gpt4all folder is changed
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - | # build and push gpt4all image to gitlab registry
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker build --rm --file ./llm/gpt4all/Dockerfile --tag ${CI_REGISTRY_IMAGE}/gpt4all:${CI_GPT4ALL_IMAGE_TAG} ./llm/gpt4all
      docker push ${CI_REGISTRY_IMAGE}/gpt4all:${CI_GPT4ALL_IMAGE_TAG}

build:llm:vllm:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      # changes:
      #   - llm/vllm/**/* # only build if llm/vllm folder is changed
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - | # build and push vllm image to gitlab registry
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker build --rm --file ./llm/vllm/Dockerfile --tag ${CI_REGISTRY_IMAGE}/vllm:${CI_VLLM_IMAGE_TAG} ./llm/vllm
      docker push ${CI_REGISTRY_IMAGE}/vllm:${CI_VLLM_IMAGE_TAG}

################## DINUM ###################

setup:llm:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp ./llm/setup.sh ./${CI_JOB_ID}/setup.sh
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      cp -r ./pyalbert ./${CI_JOB_ID}
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # download model on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./setup.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

deploy:llm:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-llm
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./llm/deploy.sh ./${CI_JOB_ID}/deploy.sh
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy vllm containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_VLLM_IMAGE_TAG=${CI_VLLM_IMAGE_TAG}
      export CI_GPT4ALL_IMAGE_TAG=${CI_GPT4ALL_IMAGE_TAG}
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./deploy.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      rm -rf ~/${CI_JOB_ID}
      "

check:llm:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: check
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp ./llm/test.sh ./${CI_JOB_ID}/test.sh
      cp -r ./llm/tests ./${CI_JOB_ID}
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # test llm containers on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/tests/requirements.txt
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./test.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

############# FRANCE SERVICES ##############

setup:llm:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp ./llm/setup.sh ./${CI_JOB_ID}/setup.sh
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      cp -r ./pyalbert ./${CI_JOB_ID}
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # download model on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./setup.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

deploy:llm:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-llm
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./llm/deploy.sh ./${CI_JOB_ID}/deploy.sh
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy vllm containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_VLLM_IMAGE_TAG=${CI_VLLM_IMAGE_TAG}
      export CI_GPT4ALL_IMAGE_TAG=${CI_GPT4ALL_IMAGE_TAG}
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./deploy.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      rm -rf ~/${CI_JOB_ID}
      "

check:llm:france services:
  environment:
    name: franceservices 
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: check
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp ./llm/test.sh ./${CI_JOB_ID}/test.sh
      cp -r ./llm/tests ./${CI_JOB_ID}
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # test llm containers on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/tests/requirements.txt
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./test.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

############################################
################### API ####################
############################################

build:api:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      # changes:
      #   - api/**/* # only build if api folder is changed
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # build and push api image to gitlab registry
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker build --rm --build-context pyalbert=./pyalbert --tag ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG} --file ./api/Dockerfile ./api
      docker push ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG}

################## DINUM ###################

setup:postprocessing:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp -r ./pyalbert ./${CI_JOB_ID}
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # download model on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      python3 ~/${CI_JOB_ID}/pyalbert/albert.py create_whitelist --config-file=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/pyalbert/config/whitelist_config.json --storage-dir=/data/whitelist
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

deploy:api:dinum:
  environment:
    name: dinum
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-api
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./api/deploy.sh ./${CI_JOB_ID}/deploy.sh
      cp ./.env ./${CI_JOB_ID}/.env
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy API containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_API_IMAGE_TAG=${CI_API_IMAGE_TAG}
      export CI_DEPLOY_URL=${CI_DEPLOY_URL}
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./deploy.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      rm -rf ~/${CI_JOB_ID}
      "

############# FRANCE SERVICES ##############

setup:postprocessing:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: setup
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send pyalbert files to remote server
      mkdir -p ./${CI_JOB_ID}/venv
      cp -r ./pyalbert ./${CI_JOB_ID}
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # download model on remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      set -e
      python3.10 -m venv ~/${CI_JOB_ID}/venv
      source ~/${CI_JOB_ID}/venv/bin/activate
      pip install -r ~/${CI_JOB_ID}/pyalbert/requirements.txt
      ln -s ~/${CI_JOB_ID}/pyalbert ~/${CI_JOB_ID}/venv/lib/python3.10/site-packages
      python3 ~/${CI_JOB_ID}/pyalbert/albert.py create_whitelist --config-file=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/pyalbert/config/whitelist_config.json --storage-dir=/data/whitelist
      deactivate
      rm -rf ~/${CI_JOB_ID}
      "

deploy:api:france services:
  environment:
    name: franceservices
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy-api
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./api/deploy.sh ./${CI_JOB_ID}/deploy.sh
      cp ./.env ./${CI_JOB_ID}/.env
      cp ./llm_routing_table.json ./${CI_JOB_ID}/llm_routing_table.json
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy API containers to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      export CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      export CI_API_IMAGE_TAG=${CI_API_IMAGE_TAG}
      export CI_DEPLOY_URL=${CI_DEPLOY_URL}
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      bash ./deploy.sh -r ./llm_routing_table.json -e ${CI_ENVIRONMENT_NAME}
      rm -rf ~/${CI_JOB_ID}
      "
